# 安全发布对象
## 发布对象
- 发布对象：使一个对象能够被当前范围之外的代码所使用。

补充：在我们平时的开发过程中，通过类的非私有方法返回对象的引用和类的公有静态变量发布对象。
```java
/**
 * 不安全的发布对象的实例
 *
 * @author
 * @create 2018-11-04 14:54
 **/
@Slf4j
@NotThreadSafe
public class UnsafePublish {

    private String[] states={"a","b","c"};

    public String[] getStates() {
        return states;
    }

    public static void main(String[] args) {
        UnsafePublish unsafePublish = new UnsafePublish();
        log.info("{}", Arrays.toString(unsafePublish.getStates()));

        //修改对象的私有属性
        unsafePublish.getStates()[0]="d";
        log.info("{}", Arrays.toString(unsafePublish.getStates()));

    }
}
```
在以上的实例中，这个类外部的类都可以通过``getStates()``这个方法来获得这个类中的私有域，如果修改私有域的属性，那么会造成发布对象的不安全性。
因此这个类是线程不安全的，因为我们无法确定其他线程是否会修改这个类中私有域的属性

- 对象溢出：一种**错误**的发布。当一个对象还没有构造完成时，就使它被其他线程所见。
```java
/**
 * 在对象未构造完成，不能将其发布
 * @author
 * @create 2018-11-04 15:00
 **/
@Slf4j
@NotThreadSafe
@NotRecommend
public class Escape {

    private int thisCanBeEscape=0;

    public Escape(){
        new InnerClass();

    }

    private class InnerClass{

        public InnerClass(){
            log.info("{}",Escape.this.thisCanBeEscape);
        }
    }

    public static void main(String[] args) {
        Escape escape = new Escape();

    }
}
```
包含了对封装实例的隐藏和引用，这样在对象没有被正确构造完成之前就会被发布，由此导致不安全的因素在里面
1. 导致this引用在构造期间溢出的错误，他是在构造函数构造过程中启动了一个线程，造成this引用的溢出
2. 新线程只是在对象构造完毕之前就已经看到他了，所以如果要在构造函数中创建线程，那么不要启动它，而是应该才用一个专有的start，或是其他的方式统一启动线程
3. 使用工厂方法和私有构造函数来完成对象创建和监听器的注册来避免不正确的发布

以上是不正确的发布了可变对象的情况，会造成两种错误：
* 发布线程以外的任何线程都可以看到发布线程**过期**的值
* 更为严重的是，线程看到对象的引用是最新的，**然而被发布对象的状态却是过期的。**
如果一个对象是可变对象，那么就需要安全发布。
## 安全发布对象的四种方法
![](../pics/publish_1.png)
单例模式的示例说明：
- 懒汉模式
```java
/**
 * 懒汉模式
 * 单例实例在第一次使用时进行创建
 * @author
 * @create 2018-11-04 21:40
 **/
@NotThreadSafe
public class SingletonExample1 {

    //私有构造函数
    private SingletonExample1(){

    }

    //单例对象
    private static SingletonExample1 instance=null;

    //静态工厂方法，在判断instance是否为空的时候可能存在线程不安全的现象
    public static SingletonExample1 getInstance(){
        if (instance==null){
            instance=new SingletonExample1();
        }
        return instance;
    }

}
```
- 饿汉模式
```java
/**
 * 饿汉模式
 * 单例实例在类装载的时候进行创建
 * 缺点 1.如果创建过程中进行很多的运算，会导致类加载的时候特别的慢
 *     2.如果创建出来的实例要很久以后才被调用，那么会导致资源的浪费
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
public class SingletonExample2 {

    //私有构造函数
    private SingletonExample2(){

    }

    //单例对象
    private static SingletonExample2 instance=new SingletonExample2();

    //静态工厂方法
    public static SingletonExample2 getInstance(){
        return instance;
    }

}
```
- 使用synchronized来改进懒汉模式
```java
/**
 * 懒汉模式
 * 单例实例在第一次使用时进行创建
 * 由于synchronized会十分影响性能，所以并不推荐
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
@NotRecommend
public class SingletonExample3 {

    //私有构造函数
    private SingletonExample3(){

    }

    //单例对象
    private static SingletonExample3 instance=null;

    //静态工厂方法
    public static synchronized SingletonExample3 getInstance(){
        if (instance==null){
            instance=new SingletonExample3();
        }
        return instance;
    }



}
```
- 使用双重锁来增强懒汉模式
```java
/**
 * 懒汉模式 -》 双重同步锁模式
 * 单例实例在第一次使用时进行创建
 * @author
 * @create 2018-11-04 21:40
 **/
@NotThreadSafe
@NotRecommend
public class SingletonExample4 {

    //私有构造函数
    private SingletonExample4(){

    }

    //单例对象
    private static SingletonExample4 instance=null;

    //静态工厂方法
    public static  SingletonExample4 getInstance(){
        if (instance==null){    //双重检测机制
            synchronized(SingletonExample4.class){  //同步锁
                instance=new SingletonExample4();
                //1. memory=allocate() 分配对象的内存空间
                //2. ctorInstance() 初始化对象
                //3. instance=memory 设置instance指向刚分配的内存

                //JVM和cpu优化，发生了指令重排
                //导致2 3顺序颠倒

            }

        }
        return instance;
    }
    
}
```
- 使用volatile+双重检测机制的懒汉模式
```java
/**
 * 懒汉模式 -》 双重同步锁模式
 * 单例实例在第一次使用时进行创建
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
@NotRecommend
public class SingletonExample5 {

    //私有构造函数
    private SingletonExample5(){

    }

    //单例对象,volatile+双重检测机制 -》 防止指令重排造成线程的不安全性
    private volatile static SingletonExample5 instance=null;

    //静态工厂方法
    public static SingletonExample5 getInstance(){
        if (instance==null){    //双重检测机制
            synchronized(SingletonExample5.class){  //同步锁
                instance=new SingletonExample5();
                //1. memory=allocate() 分配对象的内存空间
                //2. ctorInstance() 初始化对象
                //3. instance=memory 设置instance指向刚分配的内存


            }

        }
        return instance;
    }

}
```
- 使用静态代码块的饿汉模式
```java
/**
 * 饿汉模式
 *
 * 不同的静态代码块是按照顺序执行的
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
public class SingletonExample6 {

    //私有构造函数
    private SingletonExample6(){

    }

    //单例对象
    private static SingletonExample6 instance=null;

    static {
        instance=new SingletonExample6();
    }



    //静态工厂方法
    public static SingletonExample6 getInstance(){
        return instance;
    }

    public static void main(String[] args) {

        System.out.println(getInstance().hashCode());
        System.out.println(getInstance().hashCode());
    }

}
```
- 枚举模式

**最为推荐使用**
```java
/**
 * 枚举模式：
 *
 * @author
 * @create 2018-11-04 22:07
 **/
@ThreadSafe
@Recommend
public class SingletonExample7 {

    //私有构造函数
    private SingletonExample7(){

    }

    public static SingletonExample7 getInstance(){
        return Singleton.INSTANCE.getSingleton();

    }

    private enum Singleton{
        INSTANCE;

        private SingletonExample7 singleton;

        //JVM保证这个方法绝对只被调用一次
        Singleton(){
            singleton=new SingletonExample7();
        }

        public SingletonExample7 getSingleton() {
            return singleton;
        }
    }
}
```