<!-- GFM-TOC -->
* [线程安全性](#线程安全性)
    * [原子性](#原子性)
    * [可见性](#可见性)
    * [有序性](#有序性)
<!-- GFM-TOC -->

# 线程安全性

当多个线程访问某个类时，不管运行环境采用**何种调度方式**或者将这些进程如何交替执行，
并且在主调代码中**不需要任何额外的同步或者协同**，这个类都表现出**正确的行为**，
那么称这个类时线程安全的。

线程安全的三大特性：

* [原子性](#原子性):提供了互斥访问，同一时刻只能有一个线程来对它进行操作

* [可见性](#可见性)：一个线程对主内存的此稿可以及时的被其他线程观察到

* [有序性](#有序性)：一个线程观察其他线程中的指令执行顺序，
由于指令重排序的存在，该观察结果一般杂乱无序

## 原子性
**提供了互斥访问，同一时刻只能有一个线程来对它进行操作**

### 原子性之Atomic包

* AtomicXXX

CAS原理：
CAS(Compare And Swap)，即比较并交换。
是**解决多线程并行情况下使用锁造成性能损耗的一种机制**，
CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。
如果内存位置的值与**预期原值**相匹配，那么处理器会自动将该位置值更新为新值。
否则，处理器不做任何操作。
无论哪种情况，它都会在CAS指令之前返回该位置的值。
CAS有效地说明了
**我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；
否则，不要更改该位置，只告诉我这个位置现在的值即可**。

测试AtomicXXX：
```java
@ThreadSafe
public class Code_00_AtomicXXXDemo {
    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    //java.util.concurrent.atomic.AtomicInteger;
    public static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Semaphore和CountDownLatch模拟并发
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i < clientTotal ; i++) {
            executorService.execute(() -> {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println("count:{"+count.get()+"}");
    }

    public static void add() {
        count.incrementAndGet();
    }
}
输出结果：count:{5000}
```

分析：
```java
//Atomic
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

```java
//Unsafe.class
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        //获取var1对象内部偏移量为var2出的值var5
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    //判断this.compareAndSwapInt(var1, var2, var5, var5 + var4)
    //这里直接第三个参数是var5,则会返回true,并且var5=(var4+var5)。判断条件是false,结束循环。
    return var5;
}

//获取对象var1内部偏移量为var2的类型为Int的值
 public native int getIntVolatile(Object var1, long var2);

//著名的CAS
//var1是比较值所属的对象，var2需要比较的值（但实际是使用地址偏移量来实现的），
//如果var1对象中偏移量为var2处的值等于var4，那么将该处的值设置为var5并返回true，如果不等于var4则返回false。
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

* AtomicLong和LongAdder

AtomicLong是作用是对长整形进行原子操作，显而易见，在java1.8中新加入了一个新的原子类LongAdder，该类也可以保证Long类型操作的原子性，相对于AtomicLong，LongAdder有着更高的性能和更好的表现
(因为LongAdder是把一个数拆成多个数的和，修改的时候只改其中一个数，这样冲突的概率减少很多)。
在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。

```java
public class Code_01_LongAdderDemo {
    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    //java.util.concurrent.atomic.AtomicInteger;
    public static LongAdder count = new LongAdder();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Semaphore和CountDownLatch模拟并发
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i < clientTotal ; i++) {
            executorService.execute(() -> {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println("count:{"+count+"}");
    }

    public static void add() {
        count.increment();
    }
}
//输出结果：count:{5000}
```
* AtomicReference和AtomicReferenceFieldUpdater
```java
public class Code_02_AtomicReferenceDemo {
    private static AtomicReference<Integer> count=
            new AtomicReference<>(0);

    public static void main(String[] args) {
        count.compareAndSet(0,2);
        //如果值为0，就将 count更新为2
        count.compareAndSet(0,1); //不执行
        count.compareAndSet(0,1); //不执行
        count.compareAndSet(1,3); //不执行
        count.compareAndSet(2,4); //count=4
        count.compareAndSet(3,5); //不执行
        System.out.println("count:{"+count+"}");
    }
}
//输出结果：count:{4}
```
```java
public class Code_03_AtomicReferenceFieldUpdaterDemo {
    private static AtomicIntegerFieldUpdater<Code_03_AtomicReferenceFieldUpdaterDemo> updater =
            AtomicIntegerFieldUpdater.newUpdater(Code_03_AtomicReferenceFieldUpdaterDemo.class, "count");

    private volatile int count=100;

    public int getCount(){
        return count;
    }

    public static void main(String[] args) {
        Code_03_AtomicReferenceFieldUpdaterDemo self=
                new Code_03_AtomicReferenceFieldUpdaterDemo();

        if (updater.compareAndSet(self, 100, 120)) {
            System.out.println("update success 1, {"+self.getCount()+"}");
        }
        if (updater.compareAndSet(self, 100, 120)) {
            System.out.println("update success 2, {"+self.getCount()+"}");
        } else {
            System.out.println("update failed 2, {"+self.getCount()+"}");
        }
    }
}
//update success 1, {120}
//update failed 2, {120}
```
* AtomicStampReference

CAS的ABA问题：

在CAS算法中，需要取出内存中某时刻的数据（由用户完成），在下一时刻比较并替换（由CPU完成，该操作是原子的）。这个时间差中，会导致数据的变化。

假设如下事件序列：

1.线程 1 从内存位置V中取出A。

2.线程 2 从位置V中取出A。

3.线程 2 进行了一些操作，将B写入位置V。

4.线程 2 将A再次写入位置V。

5.线程 1 进行CAS操作，发现位置V中仍然是A，操作成功。

尽管线程 1 的CAS操作成功，但不代表这个过程没有问题——对于线程 1 ，线程 2 的修改已经丢失。

使用AtomicStampedReference解决ABA问题：

AtomicStampedReference除了对象值，其内部还维护了一个“状态戳”。
状态戳可类比为时间戳，是一个整数值，每一次修改对象值的同时，也要修改状态戳，
从而区分相同对象值的不同状态。
当AtomicStampedReference设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功。
```java
//比较设置 参数依次为：期望值 写入新值 期望时间戳 新时间戳
public boolean compareAndSet(V expectedReference, V newReference, 
    int expectedStamp, int newStamp)
//获得当前对象引用
public V getReference()
//获得当前时间戳
public int getStamp()
//设置当前对象引用和时间戳
public void set(V newReference, int newStamp)
```    
* AtomicBoolean
```java
public class Code_04_AtomicBooleanDemo {
    private static AtomicBoolean isHappened = new AtomicBoolean(false);

    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newCachedThreadPool();
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i < clientTotal ; i++) {
            executorService.execute(() -> {
                try {
                    semaphore.acquire();
                    test();
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println("isHappened:{"+isHappened.get()+"}");
    }

    private static void test() {
        if (isHappened.compareAndSet(false, true)) {
            //如果是false,就执行
            System.out.println("execute");
        }
    }
}
```
### 原子性之锁

## 可见性

## 有序性
