<!-- GFM-TOC -->
* [线程安全性](#线程安全性)
    * [原子性](#原子性)
    * [可见性](#可见性)
    * [有序性](#有序性)
<!-- GFM-TOC -->

# 线程安全性

当多个线程访问某个类时，不管运行环境采用**何种调度方式**或者将这些进程如何交替执行，
并且在主调代码中**不需要任何额外的同步或者协同**，这个类都表现出**正确的行为**，
那么称这个类时线程安全的。

线程安全的三大特性：

* [原子性](#原子性):提供了互斥访问，同一时刻只能有一个线程来对它进行操作

* [可见性](#可见性)：一个线程对主内存的此稿可以及时的被其他线程观察到

* [有序性](#有序性)：一个线程观察其他线程中的指令执行顺序，
由于指令重排序的存在，该观察结果一般杂乱无序

## 原子性
**提供了互斥访问，同一时刻只能有一个线程来对它进行操作**

### 原子性之Atomic包

* AtomicXXX

CAS原理：
CAS(Compare And Swap)，即比较并交换。
是**解决多线程并行情况下使用锁造成性能损耗的一种机制**，
CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。
如果内存位置的值与**预期原值**相匹配，那么处理器会自动将该位置值更新为新值。
否则，处理器不做任何操作。
无论哪种情况，它都会在CAS指令之前返回该位置的值。
CAS有效地说明了
**我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；
否则，不要更改该位置，只告诉我这个位置现在的值即可**。

测试AtomicXXX：
```java
@ThreadSafe
public class Code_00_AtomicXXXDemo {
    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    //java.util.concurrent.atomic.AtomicInteger;
    public static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Semaphore和CountDownLatch模拟并发
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i < clientTotal ; i++) {
            executorService.execute(() -> {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println("count:{"+count.get()+"}");
    }

    public static void add() {
        count.incrementAndGet();
    }
}
```
输出结果：count:{5000}

分析：
```java
//Atomic
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

```java
//Unsafe.class
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        //获取var1对象内部偏移量为var2出的值var5
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    //判断this.compareAndSwapInt(var1, var2, var5, var5 + var4)
    //这里直接第三个参数是var5,则会返回true,并且var5=(var4+var5)。判断条件是false,结束循环。
    return var5;
}

//获取对象var1内部偏移量为var2的类型为Int的值
 public native int getIntVolatile(Object var1, long var2);

//著名的CAS
//var1是比较值所属的对象，var2需要比较的值（但实际是使用地址偏移量来实现的），
//如果var1对象中偏移量为var2处的值等于var4，那么将该处的值设置为var5并返回true，如果不等于var4则返回false。
public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
```

* AtomicLong和LongAdder

AtomicLong是作用是对长整形进行原子操作，显而易见，在java1.8中新加入了一个新的原子类LongAdder，该类也可以保证Long类型操作的原子性，相对于AtomicLong，LongAdder有着更高的性能和更好的表现
(因为LongAdder是把一个数拆成多个数的和，修改的时候只改其中一个数，这样冲突的概率减少很多)。
在32位操作系统中，64位的long 和 double 变量由于会被JVM当作两个分离的32位来进行操作，所以不具有原子性。而使用AtomicLong能让long的操作保持原子型。

```java
public class Code_01_LongAdderDemo {
    // 请求总数
    public static int clientTotal = 5000;

    // 同时并发执行的线程数
    public static int threadTotal = 200;

    //java.util.concurrent.atomic.AtomicInteger;
    public static LongAdder count = new LongAdder();

    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Semaphore和CountDownLatch模拟并发
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);
        for (int i = 0; i < clientTotal ; i++) {
            executorService.execute(() -> {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        System.out.println("count:{"+count+"}");
    }

    public static void add() {
        count.increment();
    }
}
```
## 可见性

## 有序性
