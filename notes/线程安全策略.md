# 线程安全策略
  * [不可变对象](#不可变对象)
  * [线程封闭](#线程封闭)

## 不可变对象

### 1、不可变对象需要满足的条件
* 对象创建以后其状态就不能修改

* 对象所有域都是final类型

* 对象是正确创建的（在对象创建期间，this引用没有溢出）

### 2、创建不可变对象的方式（参考String类型）
* 将类声明成**final**类型，使该类不可以被继承

* 将所有的成员设置成**私有**的，使其他的类和对象不能直接访问这些成员

* 对变量**不提供set方法**

* 将所有可变的成员声明为final，这样只能对他们赋值一次

* 通过构造器初始化所有成员，进行深度拷贝

* 在get方法中，不直接返回对象本身，而是克隆对象，返回对象的拷贝

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence { //将类声明成final类型，使该类不可以被继承
     //将所有的成员设置成私有的，使其他的类和对象不能直接访问这些成员
     private final char value[];

     private int hash; // Default to 0
         
     private static final long serialVersionUID = -6849794470754667710L;
    
      
     private static final ObjectStreamField[] serialPersistentFields =
            new ObjectStreamField[0];
     //...
}
```
### 3、final关键字

* 修饰类：不能被继承（final类中的所有方法都会被隐式的声明为final方法）

* 修饰方法：

1、锁定方法不被继承类修改；

2、提升效率（private方法被隐式修饰为final方法）

* 修饰变量：

1、基本数据类型变量（初始化之后不能修改）
2、引用类型变量（初始化之后不能再修改其引用，就是不能修改地址）

### 4、其他的不可变对象的创建

* Collections.unmodifiableXXX:

Collection、List、Set、Map...

Collections.unmodifiableMap 创建完以后不允许被修改,源码如下：
```java
/**
* 初始化的时候将传进来的map赋值给一个final类型的map，
* 然后将所有会修改的方法直接抛出UnsupportedOperationException异常
 * Returns an unmodifiable view of the specified map.  This method
 * allows modules to provide users with "read-only" access to internal
 * maps.  Query operations on the returned map "read through"
 * to the specified map, and attempts to modify the returned
 * map, whether direct or via its collection views, result in an
 * <tt>UnsupportedOperationException</tt>.<p>
 *
 * The returned map will be serializable if the specified map
 * is serializable.
 */
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m) {
    return new UnmodifiableMap<>(m);
}

/**
 * @serial include
 */
private static class UnmodifiableMap<K,V> implements Map<K,V>, Serializable {
    private static final long serialVersionUID = -1034234728574286014L;

    private final Map<? extends K, ? extends V> m;

    UnmodifiableMap(Map<? extends K, ? extends V> m) {
        if (m==null)
            throw new NullPointerException();
        this.m = m;
    }

    public int size()                        {return m.size();}
    public boolean isEmpty()                 {return m.isEmpty();}
    public boolean containsKey(Object key)   {return m.containsKey(key);}
    public boolean containsValue(Object val) {return m.containsValue(val);}
    public V get(Object key)                 {return m.get(key);}

    //将所有会修改的方法直接抛出UnsupportedOperationException异常
    public V put(K key, V value) {
        throw new UnsupportedOperationException();
    }
    public V remove(Object key) {
        throw new UnsupportedOperationException();
    }
    
    // ...
}
```
```java
//@ThreadSafe
public class Code_00_Immutable {
    private static Map<Integer,Integer> map = Maps.newHashMap();

    static {
        map.put(1,2);
        map = Collections.unmodifiableMap(map);
    }

    public static void main(String[] args) {
        map.put(1,3);
    }
}
/**输出结果：
 * Exception in thread "main" java.lang.UnsupportedOperationException
 */
```

* Guava:

Collection、List、Set、Map...





## 线程封闭