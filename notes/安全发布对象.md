<!-- GFM-TOC -->
* [安全发布对象](#安全发布对象)
    * [发布对象和对象溢出](#发布对象和对象溢出)
    * [安全发布对象的四种方法](#安全发布对象的四种方法)
    * [单例模式的示例说明](#单例模式的示例说明)
<!-- GFM-TOC -->

# 安全发布对象
## 发布对象和发布对象和对象溢出
- 发布对象：使一个对象能够被当前范围之外的代码所使用。

- 对象溢出：一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见

```java
/**
 * Created by 18351 on 2018/11/5.
 * 不安全的对象发布
 */
@NotThreadSafe
public class Code_00_UnsafePublish {
    private String[] arr={"1","2","3"};

    /**
     * 通过public发布级别发布了类的域，在类的外部，任何线程都可以访问这个域.
     * 这样是不安全的，因为我们无法检查其他线程是否会修改这个域导致了错误
     */
    public String[] getArr(){
        return arr;
    }

    public static void main(String[] args) {
        Code_00_UnsafePublish unsafePublish=new Code_00_UnsafePublish();
        System.out.println(Arrays.toString(unsafePublish.getArr()));
        //输出结果：[1,2,3]

        //修改该成员变量中私有属性的值
        unsafePublish.getArr()[0]="4";
        System.out.println(Arrays.toString(unsafePublish.getArr()));
        //输出结果：[4,2,3]
    }
}

```

```java
/**
 * Created by 18351 on 2018/11/5.
 * 对象溢出的实例
 */
public class Code_01_Escape {
    private int thisCanBeEscape=0;

    public Code_01_Escape(){
        new InnerClass();
    }

    /**
     * 包含了对封装实例的隐藏和引用，这样
     * TODO:在对象没有被正确构造完成之前就会被发布，由此导致不安全的因素在里面
     * 1. 导致this引用在构造期间溢出的错误，他是在构造函数构造过程中启动了一个线程，造成this引用的溢出
     * 2. 新线程只是在对象构造完毕之前就已经看到他了，所以如果要在构造函数中创建线程，那么不要启动它，
     * 而是应该用一个专有的start，或是其他的方式统一启动线程
     * 3. 使用工厂方法和私有构造函数来完成对象创建和监听器的注册来避免不正确的发布
     */
    private class InnerClass{
        public InnerClass() {
            System.out.println(Code_01_Escape.this.thisCanBeEscape);
        }
    }

    public static void main(String[] args) {
        Code_01_Escape escape=new Code_01_Escape();
    }
}
```

## 安全发布对象的四种方法

* 在静态初始化函数中初始化一个对象引用

* 将对象的引用保存到volatile类型或者AtomicReference对象中

* 将对象的引用保存到某个正确构造对象的final类型域中

* 将对象的引用保存到一个由锁保护的域中

## 单例模式的示例说明
- 懒汉模式
```java
/**
 * 懒汉模式
 * 单例实例在第一次使用时进行创建
 * @author
 * @create 2018-11-04 21:40
 **/
@NotThreadSafe
public class SingletonExample1 {

    //私有构造函数
    private SingletonExample1(){

    }

    //单例对象
    private static SingletonExample1 instance=null;

    //静态工厂方法，在判断instance是否为空的时候可能存在线程不安全的现象
    public static SingletonExample1 getInstance(){
        if (instance==null){
            instance=new SingletonExample1();
        }
        return instance;
    }

}
```
- 饿汉模式
```java
/**
 * 饿汉模式
 * 单例实例在类装载的时候进行创建
 * 缺点 1.如果创建过程中进行很多的运算，会导致类加载的时候特别的慢
 *     2.如果创建出来的实例要很久以后才被调用，那么会导致资源的浪费
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
public class SingletonExample2 {

    //私有构造函数
    private SingletonExample2(){

    }

    //单例对象
    private static SingletonExample2 instance=new SingletonExample2();

    //静态工厂方法
    public static SingletonExample2 getInstance(){
        return instance;
    }

}
```
- 使用synchronized来改进懒汉模式
```java
/**
 * 懒汉模式
 * 单例实例在第一次使用时进行创建
 * 由于synchronized会十分影响性能，所以并不推荐
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
@NotRecommend
public class SingletonExample3 {

    //私有构造函数
    private SingletonExample3(){

    }

    //单例对象
    private static SingletonExample3 instance=null;

    //静态工厂方法
    public static synchronized SingletonExample3 getInstance(){
        if (instance==null){
            instance=new SingletonExample3();
        }
        return instance;
    }



}
```
- 使用双重锁来增强懒汉模式
```java
/**
 * 懒汉模式 -》 双重同步锁模式
 * 单例实例在第一次使用时进行创建
 * @author
 * @create 2018-11-04 21:40
 **/
@NotThreadSafe
@NotRecommend
public class SingletonExample4 {

    //私有构造函数
    private SingletonExample4(){

    }

    //单例对象
    private static SingletonExample4 instance=null;

    //静态工厂方法
    public static  SingletonExample4 getInstance(){
        if (instance==null){    //双重检测机制
            synchronized(SingletonExample4.class){  //同步锁
                instance=new SingletonExample4();
                //1. memory=allocate() 分配对象的内存空间
                //2. ctorInstance() 初始化对象
                //3. instance=memory 设置instance指向刚分配的内存

                //JVM和cpu优化，发生了指令重排
                //导致2 3顺序颠倒

            }

        }
        return instance;
    }
    
}
```
- 使用volatile+双重检测机制的懒汉模式
```java
/**
 * 懒汉模式 -》 双重同步锁模式
 * 单例实例在第一次使用时进行创建
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
@NotRecommend
public class SingletonExample5 {

    //私有构造函数
    private SingletonExample5(){

    }

    //单例对象,volatile+双重检测机制 -》 防止指令重排造成线程的不安全性
    private volatile static SingletonExample5 instance=null;

    //静态工厂方法
    public static SingletonExample5 getInstance(){
        if (instance==null){    //双重检测机制
            synchronized(SingletonExample5.class){  //同步锁
                instance=new SingletonExample5();
                //1. memory=allocate() 分配对象的内存空间
                //2. ctorInstance() 初始化对象
                //3. instance=memory 设置instance指向刚分配的内存


            }

        }
        return instance;
    }

}
```
- 使用静态代码块的饿汉模式
```java
/**
 * 饿汉模式
 *
 * 不同的静态代码块是按照顺序执行的
 * @author
 * @create 2018-11-04 21:40
 **/
@ThreadSafe
public class SingletonExample6 {

    //私有构造函数
    private SingletonExample6(){

    }

    //单例对象
    private static SingletonExample6 instance=null;

    static {
        instance=new SingletonExample6();
    }



    //静态工厂方法
    public static SingletonExample6 getInstance(){
        return instance;
    }

    public static void main(String[] args) {

        System.out.println(getInstance().hashCode());
        System.out.println(getInstance().hashCode());
    }

}
```
- 枚举模式

**最为推荐使用**
```java
/**
 * 枚举模式：
 *
 * @author
 * @create 2018-11-04 22:07
 **/
@ThreadSafe
@Recommend
public class SingletonExample7 {

    //私有构造函数
    private SingletonExample7(){

    }

    public static SingletonExample7 getInstance(){
        return Singleton.INSTANCE.getSingleton();

    }

    private enum Singleton{
        INSTANCE;

        private SingletonExample7 singleton;

        //JVM保证这个方法绝对只被调用一次
        Singleton(){
            singleton=new SingletonExample7();
        }

        public SingletonExample7 getSingleton() {
            return singleton;
        }
    }
}
```